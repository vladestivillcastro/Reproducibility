/**                                                                    
*  /file guwhiteboardtypelist_tcp_generated.h                          
*                                                                      
*  Created by Carl Lusty in 2013.                                      
*  Copyright (c) 2013 Carl Lusty                                       
*  All rights reserved.                                                
*/                                                                     


#ifndef _GUWHITEBOARD_TCP_TYPELIST_H_                                  
#define _GUWHITEBOARD_TCP_TYPELIST_H_                                  

#include "gugenericwhiteboardobject.h"                                
#include "gutcpinjectionwhiteboardobject.h"                           

#pragma clang diagnostic push                                           
#pragma clang diagnostic ignored "-Wpadded"                           
#pragma clang diagnostic ignored "-Wold-style-cast"                   


//Generated on: Wed Aug 31 14:32:05 2016
//Generated by user: vlad

namespace guWhiteboard                                                  
{                                                                       
                                                                        
extern "C"                                                            
{                                                                       
#include "guwhiteboardtypelist_c_generated.h"                         
}                                                                       
                                                                        
	/** WB Ptr Class: Print @brief print to stdout */ 
        class Print_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Print */ 
		Print_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kPrint_v, is_async) {}
		/** Constructor: Print */ 
		Print_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kPrint_v, is_async) {} 
	};

	/** WB Ptr Class: Say @brief speech output message */ 
        class Say_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Say */ 
		Say_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kSay_v, is_async) {}
		/** Constructor: Say */ 
		Say_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kSay_v, is_async) {} 
	};

	/** WB Ptr Class: Speech @brief debug speech message */ 
        class Speech_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Speech */ 
		Speech_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kSpeech_v, is_async) {}
		/** Constructor: Speech */ 
		Speech_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kSpeech_v, is_async) {} 
	};

	/** WB Ptr Class: QSay @brief speech output message (queued) */ 
        class QSay_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: QSay */ 
		QSay_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kQSay_v, is_async) {}
		/** Constructor: QSay */ 
		QSay_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kQSay_v, is_async) {} 
	};

	/** WB Ptr Class: QSpeech @brief debug speech message (queued) */ 
        class QSpeech_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: QSpeech */ 
		QSpeech_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kQSpeech_v, is_async) {}
		/** Constructor: QSpeech */ 
		QSpeech_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kQSpeech_v, is_async) {} 
	};

	/** WB Ptr Class: SpeechOutput @brief toggle, treat speech messages as silent output unless this is turned on */ 
        class SpeechOutput_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: SpeechOutput */ 
		SpeechOutput_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kSpeechOutput_v, is_async) {}
		/** Constructor: SpeechOutput */ 
		SpeechOutput_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kSpeechOutput_v, is_async) {} 
	};

	/** WB Ptr Class: GCGameState @brief game state as posted by the game controller state machine */ 

        class GCGameState_iTCP: public injection_whiteboard_object<class GCGameState > { 
	public: 
		/** Constructor: GCGameState */ 
		GCGameState_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class GCGameState >(hostname, kGCGameState_v, is_async) {} 
	};

	/** WB Ptr Class: WALK_Command @brief Class used to control the walk engine (UNSW) */ 

        class WALK_Command_iTCP: public injection_whiteboard_object<class WALK_ControlStatus > { 
	public: 
		/** Constructor: WALK_Command */ 
		WALK_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WALK_ControlStatus >(hostname, kWALK_Command_v, is_async) {} 
	};

	/** WB Ptr Class: WALK_Status @brief Class used to check the status of the walk engine (UNSW) */ 

        class WALK_Status_iTCP: public injection_whiteboard_object<class WALK_ControlStatus > { 
	public: 
		/** Constructor: WALK_Status */ 
		WALK_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WALK_ControlStatus >(hostname, kWALK_Status_v, is_async) {} 
	};

	/** WB Ptr Class: MOTION_Commands @brief WB interface for sending motion commands */ 

        class MOTION_Commands_iTCP: public injection_whiteboard_object<class MOTION_Commands > { 
	public: 
		/** Constructor: MOTION_Commands */ 
		MOTION_Commands_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class MOTION_Commands >(hostname, kMOTION_Commands_v, is_async) {} 
	};

	/** WB Ptr Class: MOTION_Status @brief WB interface for checking the status of commands sent */ 

        class MOTION_Status_iTCP: public injection_whiteboard_object<class MOTION_Status > { 
	public: 
		/** Constructor: MOTION_Status */ 
		MOTION_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class MOTION_Status >(hostname, kMOTION_Status_v, is_async) {} 
	};

	/** WB Ptr Class: HAL_HeadTarget @brief Used to alter the head position via the DCM */ 

        class HAL_HeadTarget_iTCP: public injection_whiteboard_object<class HAL_HeadTarget > { 
	public: 
		/** Constructor: HAL_HeadTarget */ 
		HAL_HeadTarget_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class HAL_HeadTarget >(hostname, kHAL_HeadTarget_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSFootSensors @brief Posts the sensor information for the feet via the DCM loop (read only) */ 

        class SENSORSFootSensors_iTCP: public injection_whiteboard_object<class SENSORSFootSensors > { 
	public: 
		/** Constructor: SENSORSFootSensors */ 
		SENSORSFootSensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSFootSensors >(hostname, kSENSORSFootSensors_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSBodySensors @brief Posts the sensor information for the body via the DCM loop (read only) */ 

        class SENSORSBodySensors_iTCP: public injection_whiteboard_object<class SENSORSBodySensors > { 
	public: 
		/** Constructor: SENSORSBodySensors */ 
		SENSORSBodySensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSBodySensors >(hostname, kSENSORSBodySensors_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSLedsSensors @brief Posts the current LEDs info, can be modified. (read/write) */ 

        class SENSORSLedsSensors_iTCP: public injection_whiteboard_object<class SENSORSLedsSensors > { 
	public: 
		/** Constructor: SENSORSLedsSensors */ 
		SENSORSLedsSensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSLedsSensors >(hostname, kSENSORSLedsSensors_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSLegJointTemps @brief Posts the temperature of the leg joints via the DCM loop (read only) */ 

        class SENSORSLegJointTemps_iTCP: public injection_whiteboard_object<class SENSORSLegJointTemps > { 
	public: 
		/** Constructor: SENSORSLegJointTemps */ 
		SENSORSLegJointTemps_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSLegJointTemps >(hostname, kSENSORSLegJointTemps_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSTorsoJointTemps @brief Posts the temperature of the torso joints via the DCM loop (read only) */ 

        class SENSORSTorsoJointTemps_iTCP: public injection_whiteboard_object<class SENSORSTorsoJointTemps > { 
	public: 
		/** Constructor: SENSORSTorsoJointTemps */ 
		SENSORSTorsoJointTemps_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSTorsoJointTemps >(hostname, kSENSORSTorsoJointTemps_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSLegJointSensors @brief Posts the joint angles of the legs via the DCM loop (read only) */ 

        class SENSORSLegJointSensors_iTCP: public injection_whiteboard_object<class SENSORSLegJointSensors > { 
	public: 
		/** Constructor: SENSORSLegJointSensors */ 
		SENSORSLegJointSensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSLegJointSensors >(hostname, kSENSORSLegJointSensors_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSTorsoJointSensors @brief Posts the joint angles of the torso via the DCM loop (read only) */ 

        class SENSORSTorsoJointSensors_iTCP: public injection_whiteboard_object<class SENSORSTorsoJointSensors > { 
	public: 
		/** Constructor: SENSORSTorsoJointSensors */ 
		SENSORSTorsoJointSensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSTorsoJointSensors >(hostname, kSENSORSTorsoJointSensors_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORSSonarSensors @brief Posts the sonar readings via the DCM loop (read only) */ 

        class SENSORSSonarSensors_iTCP: public injection_whiteboard_object<class SENSORSSonarSensors > { 
	public: 
		/** Constructor: SENSORSSonarSensors */ 
		SENSORSSonarSensors_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORSSonarSensors >(hostname, kSENSORSSonarSensors_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Control @brief Suspend, Resume, or Restart a finite state machine (clfsm) */ 

        class FSM_Control_iTCP: public injection_whiteboard_object<class FSMControlStatus > { 
	public: 
		/** Constructor: FSM_Control */ 
		FSM_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMControlStatus >(hostname, kFSM_Control_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Status @brief Current status indicating the suspended state of all FSMs.  The highest bit that is always set is the number of machines plus one. */ 

        class FSM_Status_iTCP: public injection_whiteboard_object<class FSMControlStatus > { 
	public: 
		/** Constructor: FSM_Status */ 
		FSM_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMControlStatus >(hostname, kFSM_Status_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Names @brief Request or return the names of the currently loaded FSMs.  End of list is denoted by an empty string.  Requests need to put an empty string into the first FSM name; */ 

        class FSM_Names_iTCP: public injection_whiteboard_object<class FSMNames > { 
	public: 
		/** Constructor: FSM_Names */ 
		FSM_Names_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMNames >(hostname, kFSM_Names_v, is_async) {} 
	};

	/** WB Ptr Class: FilteredGoalSighting @brief Class that contains the Kalman filtered goal objects after sighting from vision */ 

        class FilteredGoalSighting_iTCP: public injection_whiteboard_object<class FilteredArrayOneDimObjects > { 
	public: 
		/** Constructor: FilteredGoalSighting */ 
		FilteredGoalSighting_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FilteredArrayOneDimObjects >(hostname, kFilteredGoalSighting_v, is_async) {} 
	};

	/** WB Ptr Class: NAO_State @brief Stores the orientation of the robot as well as the chest button status (more to come). */ 

        class NAO_State_iTCP: public injection_whiteboard_object<class NAO_State > { 
	public: 
		/** Constructor: NAO_State */ 
		NAO_State_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NAO_State >(hostname, kNAO_State_v, is_async) {} 
	};

	/** WB Ptr Class: UDPRN @brief game state notfication from the UDP receiver. */ 

        class UDPRN_iTCP: public injection_whiteboard_object<class GCGameState > { 
	public: 
		/** Constructor: UDPRN */ 
		UDPRN_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class GCGameState >(hostname, kUDPRN_v, is_async) {} 
	};

	/** WB Ptr Class: PlayerNumber @brief what player number is this robot wearing at RoboCup in its back, retrieved from data/playernumber and posted by the UDPreceiver */ 
        class PlayerNumber_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: PlayerNumber */ 
		PlayerNumber_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kPlayerNumber_v, is_async) {}
		/** Constructor: PlayerNumber */ 
		PlayerNumber_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kPlayerNumber_v, is_async) {} 
	};

	/** WB Ptr Class: ManuallyPenalized @brief what player number is this robot wearing at RoboCup in its back whn manually penalized, from GameController FSM sent to the UDPreceiver to forward to the JAVA referee */ 
        class ManuallyPenalized_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: ManuallyPenalized */ 
		ManuallyPenalized_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kManuallyPenalized_v, is_async) {}
		/** Constructor: ManuallyPenalized */ 
		ManuallyPenalized_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kManuallyPenalized_v, is_async) {} 
	};

	/** WB Ptr Class: Vision_Control @brief control various attributes of the vision pipeline. */ 

        class Vision_Control_iTCP: public injection_whiteboard_object<class VisionControlStatus > { 
	public: 
		/** Constructor: Vision_Control */ 
		Vision_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class VisionControlStatus >(hostname, kVision_Control_v, is_async) {} 
	};

	/** WB Ptr Class: Vision_Status @brief message sent by vision that contains the current status of */ 

        class Vision_Status_iTCP: public injection_whiteboard_object<class VisionControlStatus > { 
	public: 
		/** Constructor: Vision_Status */ 
		Vision_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class VisionControlStatus >(hostname, kVision_Status_v, is_async) {} 
	};

	/** WB Ptr Class: FFTStatus @brief stereo channel RMS and list of dominant frequencies from FFT */ 

        class FFTStatus_iTCP: public injection_whiteboard_object<class FFTStatus > { 
	public: 
		/** Constructor: FFTStatus */ 
		FFTStatus_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FFTStatus >(hostname, kFFTStatus_v, is_async) {} 
	};

	/** WB Ptr Class: FSOsighting @brief Class that contains the Karman filtered  SONAR objects after a sighting */ 

        class FSOsighting_iTCP: public injection_whiteboard_object<class FilteredArrayOneDimSonar > { 
	public: 
		/** Constructor: FSOsighting */ 
		FSOsighting_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FilteredArrayOneDimSonar >(hostname, kFSOsighting_v, is_async) {} 
	};

	/** WB Ptr Class: TopParticles @brief Class that contains the top particles for possible robot positions */ 

        class TopParticles_iTCP: public injection_whiteboard_object<class TopParticles > { 
	public: 
		/** Constructor: TopParticles */ 
		TopParticles_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class TopParticles >(hostname, kTopParticles_v, is_async) {} 
	};

	/** WB Ptr Class: FilteredBallSighting @brief Class that contains the Kalman filtered top and bottom ball objects after sighting from vision */ 

        class FilteredBallSighting_iTCP: public injection_whiteboard_object<class FilteredArrayOneDimBall > { 
	public: 
		/** Constructor: FilteredBallSighting */ 
		FilteredBallSighting_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FilteredArrayOneDimBall >(hostname, kFilteredBallSighting_v, is_async) {} 
	};

	/** WB Ptr Class: PF_ControlStatus_Modes @brief what to post in the whiteboard to cause the Particle Filetr to reset, but running has no effect, it is the PF response */ 
        class PF_ControlStatus_Modes_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: PF_ControlStatus_Modes */ 
		PF_ControlStatus_Modes_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kPF_ControlStatus_Modes_v, is_async) {}
		/** Constructor: PF_ControlStatus_Modes */ 
		PF_ControlStatus_Modes_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kPF_ControlStatus_Modes_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_bridge @brief WIP Class that contains a command for WEBOTS or NXt trough a bridge */ 

        class WEBOTS_NXT_bridge_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_bridge > { 
	public: 
		/** Constructor: WEBOTS_NXT_bridge */ 
		WEBOTS_NXT_bridge_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_bridge >(hostname, kWEBOTS_NXT_bridge_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_encoders @brief Class that contains data from encoders all for WEBOTS or NXt trough a bridge */ 

        class WEBOTS_NXT_encoders_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_encoders > { 
	public: 
		/** Constructor: WEBOTS_NXT_encoders */ 
		WEBOTS_NXT_encoders_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_encoders >(hostname, kWEBOTS_NXT_encoders_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_camera @brief Class that contains data from cameta channels of  WEBOTS trough a bridge */ 

        class WEBOTS_NXT_camera_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_camera > { 
	public: 
		/** Constructor: WEBOTS_NXT_camera */ 
		WEBOTS_NXT_camera_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_camera >(hostname, kWEBOTS_NXT_camera_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_walk_isRunning @brief Class that contains boolean for checking if motion walks is running in  WEBOTS trough a bridge */ 

        class WEBOTS_NXT_walk_isRunning_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_walk_isRunning > { 
	public: 
		/** Constructor: WEBOTS_NXT_walk_isRunning */ 
		WEBOTS_NXT_walk_isRunning_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_walk_isRunning >(hostname, kWEBOTS_NXT_walk_isRunning_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_deadReakoning_walk @brief Class for dead reckoning walks in  WEBOTS trough a bridge */ 

        class WEBOTS_NXT_deadReakoning_walk_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_deadReakoning_walk > { 
	public: 
		/** Constructor: WEBOTS_NXT_deadReakoning_walk */ 
		WEBOTS_NXT_deadReakoning_walk_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_deadReakoning_walk >(hostname, kWEBOTS_NXT_deadReakoning_walk_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_colorLine_walk @brief Class for commands followign a line in  WEBOTS trough a bridge */ 

        class WEBOTS_NXT_colorLine_walk_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_colorLine_walk > { 
	public: 
		/** Constructor: WEBOTS_NXT_colorLine_walk */ 
		WEBOTS_NXT_colorLine_walk_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_colorLine_walk >(hostname, kWEBOTS_NXT_colorLine_walk_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_gridMotions @brief Class for walks on a grid of colored lines for WEBOTS trough a bridge */ 

        class WEBOTS_NXT_gridMotions_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_gridMotions > { 
	public: 
		/** Constructor: WEBOTS_NXT_gridMotions */ 
		WEBOTS_NXT_gridMotions_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_gridMotions >(hostname, kWEBOTS_NXT_gridMotions_v, is_async) {} 
	};

	/** WB Ptr Class: VisionBall @brief Class that reports the ball that vision sees. */ 

        class VisionBall_iTCP: public injection_whiteboard_object<class VisionBall > { 
	public: 
		/** Constructor: VisionBall */ 
		VisionBall_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class VisionBall >(hostname, kVisionBall_v, is_async) {} 
	};

	/** WB Ptr Class: VisionGoals @brief Class that reports the goals that vision sees. */ 

        class VisionGoals_iTCP: public injection_whiteboard_object<class VisionGoals > { 
	public: 
		/** Constructor: VisionGoals */ 
		VisionGoals_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class VisionGoals >(hostname, kVisionGoals_v, is_async) {} 
	};

	/** WB Ptr Class: WalkData @brief Class to report Walk Data. */ 

        class WalkData_iTCP: public injection_whiteboard_object<class WalkData > { 
	public: 
		/** Constructor: WalkData */ 
		WalkData_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WalkData >(hostname, kWalkData_v, is_async) {} 
	};

	/** WB Ptr Class: TeleoperationControlStatus @brief Class for sending teleoperation commands */ 

        class TeleoperationControlStatus_iTCP: public injection_whiteboard_object<class TeleoperationControlStatus > { 
	public: 
		/** Constructor: TeleoperationControlStatus */ 
		TeleoperationControlStatus_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class TeleoperationControlStatus >(hostname, kTeleoperationControlStatus_v, is_async) {} 
	};

	/** WB Ptr Class: TeleoperationConnection @brief "Integer indication which remote whiteboard teleoperation instructions are on" */ 
        class TeleoperationConnection_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: TeleoperationConnection */ 
		TeleoperationConnection_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kTeleoperationConnection_v, is_async) {}
		/** Constructor: TeleoperationConnection */ 
		TeleoperationConnection_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kTeleoperationConnection_v, is_async) {} 
	};

	/** WB Ptr Class: UDPWBNumber @brief "ID number being used to broadcast udp whiteboard" */ 
        class UDPWBNumber_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: UDPWBNumber */ 
		UDPWBNumber_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kUDPWBNumber_v, is_async) {}
		/** Constructor: UDPWBNumber */ 
		UDPWBNumber_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kUDPWBNumber_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_bumper @brief Class that contains data from 2 rouch sensors in an NXT bumper by the bridge */ 

        class WEBOTS_NXT_bumper_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_bumper > { 
	public: 
		/** Constructor: WEBOTS_NXT_bumper */ 
		WEBOTS_NXT_bumper_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_bumper >(hostname, kWEBOTS_NXT_bumper_v, is_async) {} 
	};

	/** WB Ptr Class: WEBOTS_NXT_vector_bridge @brief Class that will define actuators for the Diferential motor bridge */ 

        class WEBOTS_NXT_vector_bridge_iTCP: public injection_whiteboard_object<class WEBOTS_NXT_vector_bridge > { 
	public: 
		/** Constructor: WEBOTS_NXT_vector_bridge */ 
		WEBOTS_NXT_vector_bridge_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WEBOTS_NXT_vector_bridge >(hostname, kWEBOTS_NXT_vector_bridge_v, is_async) {} 
	};

	/** WB Ptr Class: VisionLines @brief Class that reports the lines that vision sees. */ 

        class VisionLines_iTCP: public injection_whiteboard_object<class VisionLines > { 
	public: 
		/** Constructor: VisionLines */ 
		VisionLines_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class VisionLines >(hostname, kVisionLines_v, is_async) {} 
	};

	/** WB Ptr Class: DifferentialRobotStatus @brief Class that reads differential robot status */ 

        class DifferentialRobotStatus_iTCP: public injection_whiteboard_object<class DifferentialRobotControlStatus > { 
	public: 
		/** Constructor: DifferentialRobotStatus */ 
		DifferentialRobotStatus_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class DifferentialRobotControlStatus >(hostname, kDifferentialRobotStatus_v, is_async) {} 
	};

	/** WB Ptr Class: DifferentialRobotControl @brief Class that sends commands to the robot from the whiteboard */ 

        class DifferentialRobotControl_iTCP: public injection_whiteboard_object<class DifferentialRobotControlStatus > { 
	public: 
		/** Constructor: DifferentialRobotControl */ 
		DifferentialRobotControl_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class DifferentialRobotControlStatus >(hostname, kDifferentialRobotControl_v, is_async) {} 
	};

	/** WB Ptr Class: XEyesPos @brief Just a hook for an xeyes interface */ 

        class XEyesPos_iTCP: public injection_whiteboard_object<class Point2D > { 
	public: 
		/** Constructor: XEyesPos */ 
		XEyesPos_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Point2D >(hostname, kXEyesPos_v, is_async) {} 
	};

	/** WB Ptr Class: VisionFace @brief Face seen by Vision */ 
        class VisionFace_iTCP: public injection_whiteboard_object<std::vector<int> > { 
	public: 
		/** Constructor: VisionFace */ 
		VisionFace_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::vector<int> >(hostname, kVisionFace_v, is_async) {}
		/** Constructor: VisionFace */ 
		VisionFace_iTCP(std::vector<int> value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::vector<int> >(value, hostname, kVisionFace_v, is_async) {} 
	};

	/** WB Ptr Class: Draw @brief Used by the half made GUDraw module in posix */ 
        class Draw_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Draw */ 
		Draw_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kDraw_v, is_async) {}
		/** Constructor: Draw */ 
		Draw_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kDraw_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_States @brief Idempotent Message publicising the state -about to be executed- (0-254) of up-to the first 128 machines (0-127).  State -INVALDMACHINE- (255) is posted for MachineIDs that are not currently loaded. */ 

        class FSM_States_iTCP: public injection_whiteboard_object<class FSMState > { 
	public: 
		/** Constructor: FSM_States */ 
		FSM_States_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMState >(hostname, kFSM_States_v, is_async) {} 
	};

	/** WB Ptr Class: Giraff_Interface_Status @brief Serial interface for the main motor and sensor board of the giraff */ 

        class Giraff_Interface_Status_iTCP: public injection_whiteboard_object<class Giraff_MainSerialInterface > { 
	public: 
		/** Constructor: Giraff_Interface_Status */ 
		Giraff_Interface_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Giraff_MainSerialInterface >(hostname, kGiraff_Interface_Status_v, is_async) {} 
	};

	/** WB Ptr Class: Giraff_Interface_Command @brief Serial interface for the main motor and sensor board of the giraff */ 

        class Giraff_Interface_Command_iTCP: public injection_whiteboard_object<class Giraff_MainSerialInterface > { 
	public: 
		/** Constructor: Giraff_Interface_Command */ 
		Giraff_Interface_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Giraff_MainSerialInterface >(hostname, kGiraff_Interface_Command_v, is_async) {} 
	};

	/** WB Ptr Class: NXT_Status @brief Contains sensor data as well as motor encoder data from the objects attached to an NXT */ 

        class NXT_Status_iTCP: public injection_whiteboard_object<class NXT_Interface > { 
	public: 
		/** Constructor: NXT_Status */ 
		NXT_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NXT_Interface >(hostname, kNXT_Status_v, is_async) {} 
	};

	/** WB Ptr Class: NXT_Command @brief Can issue commands to set the motors of an NXT and reset the encoders */ 

        class NXT_Command_iTCP: public injection_whiteboard_object<class NXT_Interface > { 
	public: 
		/** Constructor: NXT_Command */ 
		NXT_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NXT_Interface >(hostname, kNXT_Command_v, is_async) {} 
	};

	/** WB Ptr Class: APM_Status @brief Contains sensor data from an APM */ 

        class APM_Status_iTCP: public injection_whiteboard_object<class APM_Interface > { 
	public: 
		/** Constructor: APM_Status */ 
		APM_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class APM_Interface >(hostname, kAPM_Status_v, is_async) {} 
	};

	/** WB Ptr Class: APM_Command @brief Can issue commands to an APM */ 

        class APM_Command_iTCP: public injection_whiteboard_object<class APM_Interface > { 
	public: 
		/** Constructor: APM_Command */ 
		APM_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class APM_Interface >(hostname, kAPM_Command_v, is_async) {} 
	};

	/** WB Ptr Class: WALK2014_Command @brief Class used to control the 2014 walk engine (UNSW) */ 

        class WALK2014_Command_iTCP: public injection_whiteboard_object<class WALK2014_ControlStatus > { 
	public: 
		/** Constructor: WALK2014_Command */ 
		WALK2014_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WALK2014_ControlStatus >(hostname, kWALK2014_Command_v, is_async) {} 
	};

	/** WB Ptr Class: WALK2014_Status @brief Class used to check the status of the 2014 walk engine (UNSW) */ 

        class WALK2014_Status_iTCP: public injection_whiteboard_object<class WALK2014_ControlStatus > { 
	public: 
		/** Constructor: WALK2014_Status */ 
		WALK2014_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class WALK2014_ControlStatus >(hostname, kWALK2014_Status_v, is_async) {} 
	};

	/** WB Ptr Class: CBall @brief Status Message for the color of the ball */ 
        class CBall_iTCP: public injection_whiteboard_object<int > { 
	public: 
		/** Constructor: CBall */ 
		CBall_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(hostname, kCBall_v, is_async) {}
		/** Constructor: CBall */ 
		CBall_iTCP(int value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<int >(value, hostname, kCBall_v, is_async) {} 
	};

	/** WB Ptr Class: OculusPrime_Command @brief Class used to control the Oculus Prime movements, controls etc. */ 

        class OculusPrime_Command_iTCP: public injection_whiteboard_object<class OculusPrimeInterface > { 
	public: 
		/** Constructor: OculusPrime_Command */ 
		OculusPrime_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class OculusPrimeInterface >(hostname, kOculusPrime_Command_v, is_async) {} 
	};

	/** WB Ptr Class: Input3D @brief for 3d input devices such as the leap or a joystick */ 

        class Input3D_iTCP: public injection_whiteboard_object<class Input3D > { 
	public: 
		/** Constructor: Input3D */ 
		Input3D_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Input3D >(hostname, kInput3D_v, is_async) {} 
	};

	/** WB Ptr Class: Oculus_Prime_Command @brief Serial interface for the main motor and sensor board of the oculus prime */ 

        class Oculus_Prime_Command_iTCP: public injection_whiteboard_object<class Oculus_PrimeSerialInterface > { 
	public: 
		/** Constructor: Oculus_Prime_Command */ 
		Oculus_Prime_Command_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Oculus_PrimeSerialInterface >(hostname, kOculus_Prime_Command_v, is_async) {} 
	};

	/** WB Ptr Class: IOPins @brief Arduino-style I/O pins */ 

        class IOPins_iTCP: public injection_whiteboard_object<class IOPins > { 
	public: 
		/** Constructor: IOPins */ 
		IOPins_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class IOPins >(hostname, kIOPins_v, is_async) {} 
	};

	/** WB Ptr Class: NXT_Two_Touch_Status @brief Class that reads NXT's two buttons */ 

        class NXT_Two_Touch_Status_iTCP: public injection_whiteboard_object<class NXT_Two_Touch_Status > { 
	public: 
		/** Constructor: NXT_Two_Touch_Status */ 
		NXT_Two_Touch_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NXT_Two_Touch_Status >(hostname, kNXT_Two_Touch_Status_v, is_async) {} 
	};

	/** WB Ptr Class: NXT_Sound_Control @brief Class that produces NXT's sounds */ 

        class NXT_Sound_Control_iTCP: public injection_whiteboard_object<class NXT_Sound_Control > { 
	public: 
		/** Constructor: NXT_Sound_Control */ 
		NXT_Sound_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NXT_Sound_Control >(hostname, kNXT_Sound_Control_v, is_async) {} 
	};

	/** WB Ptr Class: NXT_Lights_Control @brief Class that places power in NXT's for lights */ 

        class NXT_Lights_Control_iTCP: public injection_whiteboard_object<class NXT_Lights_Control > { 
	public: 
		/** Constructor: NXT_Lights_Control */ 
		NXT_Lights_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class NXT_Lights_Control >(hostname, kNXT_Lights_Control_v, is_async) {} 
	};

	/** WB Ptr Class: Clocks @brief Class for keeping track of time */ 

        class Clocks_iTCP: public injection_whiteboard_object<class Clocks > { 
	public: 
		/** Constructor: Clocks */ 
		Clocks_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Clocks >(hostname, kClocks_v, is_async) {} 
	};

	/** WB Ptr Class: Channels @brief UPPAAL-Style synchronisation channels */ 

        class Channels_iTCP: public injection_whiteboard_object<class Channels > { 
	public: 
		/** Constructor: Channels */ 
		Channels_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Channels >(hostname, kChannels_v, is_async) {} 
	};

	/** WB Ptr Class: SwitchSubsumption @brief class:SwitchSubsumption, nonatomic, SwitchSubsumption, "SwitchSubsumption" */ 

        class SwitchSubsumption_iTCP: public injection_whiteboard_object<class SwitchSubsumption > { 
	public: 
		/** Constructor: SwitchSubsumption */ 
		SwitchSubsumption_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SwitchSubsumption >(hostname, kSwitchSubsumption_v, is_async) {} 
	};

	/** WB Ptr Class: TotoDoingMotion @brief class:TotoDoingMotion, nonatomic, TotoDoingMotion, "TotoDoingMotion" */ 

        class TotoDoingMotion_iTCP: public injection_whiteboard_object<class TotoDoingMotion > { 
	public: 
		/** Constructor: TotoDoingMotion */ 
		TotoDoingMotion_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class TotoDoingMotion >(hostname, kTotoDoingMotion_v, is_async) {} 
	};

	/** WB Ptr Class: Count @brief class:wb_count, nonatomic, Count, "A Simple Integer" */ 

        class Count_iTCP: public injection_whiteboard_object<class wb_count > { 
	public: 
		/** Constructor: Count */ 
		Count_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class wb_count >(hostname, kCount_v, is_async) {} 
	};

	/** WB Ptr Class: GreenEWon @brief status of the EWgreen light */ 
        class GreenEWon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: GreenEWon */ 
		GreenEWon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kGreenEWon_v, is_async) {}
		/** Constructor: GreenEWon */ 
		GreenEWon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kGreenEWon_v, is_async) {} 
	};

	/** WB Ptr Class: WarnEW @brief status of the recommendaiton of the EW light */ 
        class WarnEW_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: WarnEW */ 
		WarnEW_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kWarnEW_v, is_async) {}
		/** Constructor: WarnEW */ 
		WarnEW_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kWarnEW_v, is_async) {} 
	};

	/** WB Ptr Class: TimeGTthirty @brief status of the timer with respect to 30 */ 
        class TimeGTthirty_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: TimeGTthirty */ 
		TimeGTthirty_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kTimeGTthirty_v, is_async) {}
		/** Constructor: TimeGTthirty */ 
		TimeGTthirty_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kTimeGTthirty_v, is_async) {} 
	};

	/** WB Ptr Class: AmberEWon @brief status of the EWamber light */ 
        class AmberEWon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: AmberEWon */ 
		AmberEWon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kAmberEWon_v, is_async) {}
		/** Constructor: AmberEWon */ 
		AmberEWon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kAmberEWon_v, is_async) {} 
	};

	/** WB Ptr Class: TurnRedEW @brief second status of the recommendaiton of the EW light */ 
        class TurnRedEW_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: TurnRedEW */ 
		TurnRedEW_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kTurnRedEW_v, is_async) {}
		/** Constructor: TurnRedEW */ 
		TurnRedEW_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kTurnRedEW_v, is_async) {} 
	};

	/** WB Ptr Class: TimeGTfive @brief status of the timer with respect to 5 */ 
        class TimeGTfive_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: TimeGTfive */ 
		TimeGTfive_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kTimeGTfive_v, is_async) {}
		/** Constructor: TimeGTfive */ 
		TimeGTfive_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kTimeGTfive_v, is_async) {} 
	};

	/** WB Ptr Class: RedEWon @brief status of the EWred light */ 
        class RedEWon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: RedEWon */ 
		RedEWon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kRedEWon_v, is_async) {}
		/** Constructor: RedEWon */ 
		RedEWon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kRedEWon_v, is_async) {} 
	};

	/** WB Ptr Class: GreenNSon @brief status of the NSgreen light */ 
        class GreenNSon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: GreenNSon */ 
		GreenNSon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kGreenNSon_v, is_async) {}
		/** Constructor: GreenNSon */ 
		GreenNSon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kGreenNSon_v, is_async) {} 
	};

	/** WB Ptr Class: WarnNS @brief status of the recommendaiton of the NS light */ 
        class WarnNS_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: WarnNS */ 
		WarnNS_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kWarnNS_v, is_async) {}
		/** Constructor: WarnNS */ 
		WarnNS_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kWarnNS_v, is_async) {} 
	};

	/** WB Ptr Class: AmberNSon @brief status of the NSamber light */ 
        class AmberNSon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: AmberNSon */ 
		AmberNSon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kAmberNSon_v, is_async) {}
		/** Constructor: AmberNSon */ 
		AmberNSon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kAmberNSon_v, is_async) {} 
	};

	/** WB Ptr Class: TurnRedNS @brief second status of the recommendaiton of the NS light */ 
        class TurnRedNS_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: TurnRedNS */ 
		TurnRedNS_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kTurnRedNS_v, is_async) {}
		/** Constructor: TurnRedNS */ 
		TurnRedNS_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kTurnRedNS_v, is_async) {} 
	};

	/** WB Ptr Class: RedNSon @brief status of the NSred light */ 
        class RedNSon_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: RedNSon */ 
		RedNSon_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kRedNSon_v, is_async) {}
		/** Constructor: RedNSon */ 
		RedNSon_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kRedNSon_v, is_async) {} 
	};

	/** WB Ptr Class: TimerReset @brief flag to reset timer */ 
        class TimerReset_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: TimerReset */ 
		TimerReset_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kTimerReset_v, is_async) {}
		/** Constructor: TimerReset */ 
		TimerReset_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kTimerReset_v, is_async) {} 
	};

	/** WB Ptr Class: IoT_Control @brief Used to manage a group of IoT nodes (personal, Carl) */ 

        class IoT_Control_iTCP: public injection_whiteboard_object<class IoT_Control > { 
	public: 
		/** Constructor: IoT_Control */ 
		IoT_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class IoT_Control >(hostname, kIoT_Control_v, is_async) {} 
	};

	/** WB Ptr Class: CarSensorPressed @brief flag to indicate status of sensor for cars */ 
        class CarSensorPressed_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: CarSensorPressed */ 
		CarSensorPressed_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kCarSensorPressed_v, is_async) {}
		/** Constructor: CarSensorPressed */ 
		CarSensorPressed_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kCarSensorPressed_v, is_async) {} 
	};

	/** WB Ptr Class: SwitchSubsumptionTrafficLights @brief class:SwitchSubsumptionTrafficLights, nonatomic, SwitchSubsumptionTrafficLights, "SwitchSubsumptionTrafficLights" */ 

        class SwitchSubsumptionTrafficLights_iTCP: public injection_whiteboard_object<class SwitchSubsumptionTrafficLights > { 
	public: 
		/** Constructor: SwitchSubsumptionTrafficLights */ 
		SwitchSubsumptionTrafficLights_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SwitchSubsumptionTrafficLights >(hostname, kSwitchSubsumptionTrafficLights_v, is_async) {} 
	};

}

#pragma clang diagnostic pop

#endif                          
